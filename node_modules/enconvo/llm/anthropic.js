const {BaseChatModel} = require("langchain/chat_models/base");
const {AIMessage} = require("langchain/schema");
// const {val} = require("cheerio/lib/api/attributes");
// const anthropicStreamValue = require("./util/anthropic_parse_stream_value");

const AI_PROMPT = '\n\nAssistant:';
const HUMAN_PROMPT = '\n\nHuman:';

function getAnthropicPromptFromMessage(type) {
    switch (type) {
        case "ai":
            return AI_PROMPT;
        case "human":
            return HUMAN_PROMPT;
        case "system":
            return "";
        default:
            throw new Error(`Unknown message type: ${type}`);
    }
}

const DEFAULT_STOP_SEQUENCES = [HUMAN_PROMPT];

/**
 * Wrapper around Anthropic large language models.
 *
 * To use you should have the `@anthropic-ai/sdk` package installed, with the
 * `ANTHROPIC_API_KEY` environment variable set.
 *
 * @remarks
 * Any parameters that are valid to be passed to {@link
    * https://console.anthropic.com/docs/api/reference |
 * `anthropic.complete`} can be passed through {@link invocationKwargs},
 * even if not explicitly available on this class.
 *
 */
class ChatAnthropic extends BaseChatModel {
    get lc_secrets() {
        return {
            anthropicApiKey: "ANTHROPIC_API_KEY",
        };
    }

    get lc_aliases() {
        return {
            modelName: "model",
        };
    }

    constructor(fields) {
        super(fields ?? {});
        Object.defineProperty(this, "lc_serializable", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: true
        });
        Object.defineProperty(this, "anthropicApiKey", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "apiUrl", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "temperature", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 1
        });
        Object.defineProperty(this, "topK", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: -1
        });
        Object.defineProperty(this, "topP", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: -1
        });
        Object.defineProperty(this, "maxTokensToSample", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 2048
        });
        Object.defineProperty(this, "modelName", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "claude-v1"
        });
        Object.defineProperty(this, "invocationKwargs", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "stopSequences", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "streaming", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        // Used for non-streaming requests
        Object.defineProperty(this, "batchClient", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        // Used for streaming requests
        Object.defineProperty(this, "streamingClient", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.anthropicApiKey =
            fields?.anthropicApiKey;
        if (!this.anthropicApiKey) {
            throw new Error("Anthropic API key not found");
        }
        // Support overriding the default API URL (i.e., https://api.anthropic.com)
        this.apiUrl = fields?.anthropicApiUrl;
        this.modelName = fields?.modelName ?? this.modelName;
        this.invocationKwargs = fields?.invocationKwargs ?? {};
        this.temperature = fields?.temperature ?? this.temperature;
        this.topK = fields?.topK ?? this.topK;
        this.topP = fields?.topP ?? this.topP;
        this.maxTokensToSample =
            fields?.maxTokensToSample ?? this.maxTokensToSample;
        this.stopSequences = fields?.stopSequences ?? this.stopSequences;
        this.streaming = fields?.streaming ?? false;
    }

    /**
     * Get the parameters used to invoke the model
     */
    invocationParams(options) {
        return {
            model: this.modelName,
            temperature: this.temperature,
            top_k: this.topK,
            top_p: this.topP,
            stop_sequences: options?.stop?.concat(DEFAULT_STOP_SEQUENCES) ??
                this.stopSequences ??
                DEFAULT_STOP_SEQUENCES,
            max_tokens_to_sample: this.maxTokensToSample,
            stream: this.streaming,
            ...this.invocationKwargs,
        };
    }

    /** @ignore */
    _identifyingParams() {
        return {
            model_name: this.modelName,
            ...this.invocationParams(),
        };
    }

    /**
     * Get the identifying parameters for the model
     */
    identifyingParams() {
        return {
            model_name: this.modelName,
            ...this.invocationParams(),
        };
    }

    formatMessagesAsPrompt(messages) {
        return (messages
            .map((message) => {
                const messagePrompt = getAnthropicPromptFromMessage(message._getType());
                return `${messagePrompt} ${message.content}`;
            })
            .join("") + AI_PROMPT);
    }

    /** @ignore */
    async _generate(messages, options, runManager) {
        if (this.stopSequences && options.stop) {
            throw new Error(`"stopSequence" parameter found in input and default params`);
        }
        const params = this.invocationParams(options);
        const response = await this.completionWithRetry({
            ...params,
            prompt: this.formatMessagesAsPrompt(messages),
        }, {signal: options.signal}, runManager);
        const generations = response.completion
            .split(AI_PROMPT)
            .map((message) => ({
                text: message,
                message: new AIMessage(message),
            }));
        return {
            generations,
        };
    }

    /** @ignore */
    async completionWithRetry(request, options, runManager) {
        if (!this.anthropicApiKey) {
            throw new Error("Missing Anthropic API key.");
        }
        let makeCompletionRequest;
        let asyncCallerOptions = {};

        const axiosOptions = {
            ...options,
            headers: {
                "X-Api-Key": this.anthropicApiKey
            }
        };

        // if (!this.batchClient) {
        //     const options = this.apiUrl ? { apiUrl: this.apiUrl } : undefined;
        // }

        asyncCallerOptions = {signal: options.signal};

        console.log(`request: ${JSON.stringify(request)}`)

        makeCompletionRequest = async () => {
            // const res = await fetch('https://jsonplaceholder.typicode.com/todos/1')
            let url = `https://api.anthropic.com/v1/complete`;
            console.log(`url: ${url}`)
            // let url = `${this.endpoint}/chat/completions`;
            // 把 axiosOptions.params 里的参数拼接到 url 后面
            const resp = await fetch(url, {
                method: "POST", // *GET, POST, PUT, DELETE, etc.
                headers: {
                    "Content-Type": "application/json",
                    ...axiosOptions.headers
                },
                body: JSON.stringify(request), // body data type must match "Content-Type" header
            });

            if (request.stream) {
                // const text = await resp.onmessage((value, end) => {
                //     value = anthropicStreamValue(value)
                //     console.log(`value: ${value}`)
                //     if (value.event === "completion") {
                //         runManager?.handleLLMNewToken(value.data.completion ?? "");
                //     }
                // })
                // return JSON.parse(text);
            } else {
                const json = await resp.json();
                console.log(`${JSON.stringify(json)}`)
                return json;
            }
        };

        return this.caller.callWithOptions(asyncCallerOptions, makeCompletionRequest);
    }

    _llmType() {
        return "anthropic";
    }

    /** @ignore */
    _combineLLMOutput() {
        return [];
    }
}


module.exports = {ChatAnthropic};
